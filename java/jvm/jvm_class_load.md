# JVM类加载机制
JVM内置三个类加载器，启动类加载器、扩展类加载器、应用程序类加载器。他们分别加载不同层面的类，并且是依次是派生关系，最顶层是启动类加载器，不可被程序自主操作，也非Java实现。除了启动类加载器，都是java.lang.ClassLoader的子类。用户自定义的类加载器则继承自应用程序类加载器。

jvm对class文件采用的是按需加载的方式，需要使用时才加载。

## 类加载器工作流程

类加载器加载Class大致如下：

- 检测缓冲区中是否有此Class，有则返回对应的java.lang.Class对象。
- 找父类加载器。
- 如果找到父类加载器，则使用父类加载器加载目标类，成功则返回对应的java.lang.Class对象。失败则使用当前类加载器加载目标类。
- 如果没有父类加载器，使用根类加载器去载入目标类，成功则返回对应的java.lang.Class对象，失败则抛出ClassNotFountException异常。
- 当父类加载目标类不成功时，才由自己的类加载器对读取Class文件，文件找不到或者找到文件仍载入Class不成功则抛出ClassNotFountException异常，加载成功后则返回对应的java.lang.Class对象。

JVM的类加载机制有下面几个特点：

- 全盘负责：类加载器加载Class时，该Class所依赖和引用其他Class也将由该类加载器载入。
- 代理模式：先让父类加载器试图加载该Class；只有父加载器无法加载时，才自己去加载。
- 缓存机制：所有加载过的Class都会被缓存，类加载器先从缓存区中搜寻该Class，不存在时才会从二进制数据中加载，并放入缓存。

## 双亲委派机制

双亲委派，即把请求交给父类处理的一种任务委派模式，是代理模式的一种。核心思想是先自底向上检查类是否已加载；再自顶向下尝试加载类。具体原理如下：

- 如果一个类加载器接收到了类加载的请求，首先会把这个请求委托给父类加载器去执行。
- 如果父类还存在父类加载器，则继续向上委托，一直委托到启动类加载器。
- 如果父类加载器可以完成加载任务，就返回成功结果，如果父类加载失败，就由子类自己去尝试加载，如果子类加载失败就会抛出ClassNotFoundException异常。

双亲委派机制是为了保证 Java 核心库的类型安全，保证不会出现用户自己能定义核心类库的情况，防止内存中出现多份同样的字节码。

## 自定义的类加载器注意点

自定义的类加载器继承java.lang.ClassLoader，其中关键的方法是loadClass，在这个方法中又调用了findLoadedClass方法。

- 如果不想打破双亲委派模型，那么只需要重写findClass方法。

- 如果想打破双亲委派模型，那么就重写整个loadClass方法。

在findClass中，主要是读.class文件，把二进制数据交给defineClass方法转换成Class类的实例。

Tomcat的类加载器则是打破了双亲委派规则，因为需要隔离各个应用的class，并且要共用common下的类。

用于SPI的线程上下文类加载器，是父类加载器请求子类加载器去完成目标类的加载动作。因为SPI上Java只提供技术标准，各厂商提供具体的实现类（如JDBC），那么对于目标类的载就不能走双亲委派的加载方式，只能从当前的类加载器中去加载。

