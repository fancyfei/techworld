# 垃圾回收设计
GC就是“自动内存管理系统”。它是一个能把不再需要的内存空间自动释放和回收的机制。
目前存在的多种GC算法大都是对标记-清除算法、复制收集法、引用计数法的拆分组合。
GC核心算法就是判断对象是否存活和不同的回收策略。

- 两种对象是否存活判断方法：根搜索算法（可达性分析法或者引用链法，标记-清除算法、复制收集法都是这个方式）；另外一个是引用计数法。
- 垃圾的定义：那些不被直接或间接的引用的对象视为“死亡”，就是所谓垃圾，是需要回收。
- 根：就是判断对象是否被引用的起始点。不同语言会有不同规定，但基本上是将变量和运行栈空间作为根。

## 标记-清除算法
标记清除（Mark and Sweep）是最早的GC算法，有两个阶段：标记阶段，清除阶段。
首先从根开始将可能被引用的对象用递归的方式进行标记，然后将没有标记到的对象作为垃圾进行回收。
> 它有一变种算法：标记压缩（Mark and Compat）的算法。

标记清除在处理大量对象需要清理时，需要遍历垃圾对象，整体消耗的时间比较长。

## 复制收集法
复制收集（Copy and Collection），改进了标记清除算法。总体流程是：开辟新空间，复制对象，清空旧空间。
将从根开始被引用的对象复制到另外的空间中，然后，再将复制的对象所能够引用的对象用递归的方式不断复制下去。

复制收集算法对空间消耗比较大，另外在处理大量对象是存活状态的情况，效果很差。

## 引用计数法
引用计数方式（Reference Counting），也是最简单也最容易实现的一种，与清除算法差不多时间发明出来。
它的原理是：在每个对象中保存该对象的引用计数，当引用发生增减时对计数进行更新引用计数减至0，该对象的内存就会被释放。

它对循环引用对象无法释放，运行效率也比较差，但是不会引起长时间的卡顿。适用场景很有限。

## GC的主要性能指标
- 吞吐量：应用程序花费在非GC上的时间百分比，应用程序耗时/系统总运行时间。
- GC负载：指应用程序花在GC上的时间百分比，GC耗时/系统总运行时间。
- 停顿stw（Stop The World）：停顿时长，也就是不可用时间或者叫延迟。
- 反应时间，当一个对象变成垃圾后，多长时间内被释放。
- 垃圾回收频率，多长时间回收一次。

## Java的垃圾回收设计
- 垃圾回收主要是在Java堆区和方法区内存，这部分内存分配和回收是动态的。
程序计数器、虚拟机栈和本地方法栈3个区域随线程启动与销毁，则不需要考虑回收。
- 现代的收集器基本都采用分代收集算法。
- JDK7,JDK8的默认垃圾收集器的组合是：年轻代用并行吞吐量优先收集器（Parallel Scavenge），老年代用串行收集器（Serial Old）。
- 从JDK9开始默认垃圾收集器G1（Garbage-First）。